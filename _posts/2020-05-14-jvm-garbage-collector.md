---
layout: post
title: jvm-垃圾收集器
date: 2020-05-14
categories: 学习笔记
tags: Jvm
comments: true
---

[之前文章介绍过垃圾回收机制](https://diego1109.github.io/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2020/05/12/jvm-garbage-collection-theory/)，这篇文章垃圾回收的实际执行者--垃圾回收器。按照是否可并行，垃圾回收器可分为串行垃圾回收器和并行垃圾回收器；按照作用区域，可分为新生代垃圾回收器和老年代垃圾回收器。下图是按照作用区域将几款经典的收集器进行划分。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/diego1109/diego1109.github.io/images/collectors.png">
</div>

## Serial

**Serial是新生代串行回收器，采用标记-复制算法，它也是最早的垃圾收集器，目前会用在客户端模式下**。串行收集器表明该收集器在执行时只会使用一条线程去晚上垃圾收集工作，而且在进行垃圾收集时，必须暂停用户其他所有的线程，直到它收集结束。“Stop The World”是为了配合可达性分析，但这项工作是在用户不可知的情况下，由虚拟机自发启动和完成的，对于实时性要求比较高的场景，STW带给用户很糟糕的体验。**后续的每个新设计出来的虚拟机都在把降低STW的时间作为目标之一**。

## ParNew

**ParNet是新生代的并行收集器，更确切的说她只是Serial收集器的多线程版本**，除了多收集垃圾以外，采用算法等其他功能都与Serial是一样的。所以ParNew在执行垃圾收集也需要暂停用户线程，但因为是多线程收集，暂停的时间减少了（在多核cpu环境下），在单核CPU中，ParNew的收集效率就没有Serial强了，因为每个时刻CPU都只能执行一个线程，ParNew线程之间的切换会产生时间开销。

## Parallel Scavenge

Parallel Scavenge 是新生代多线程收集器，采用标记-复制算法。该收集器的目标是达到一个可控的吞吐量（ThroughPut），**吞吐量就是：处理器用于处理用户代码的时间与处理器总消耗时间（用户代码花费时间与垃圾收集花费时间的和）的比值**，很明显，比值越大，垃圾收集占用的时间就越小，程序的响应速度就越好。为了达到这个目的，该收集器提供了两个参数用于精确控制吞吐量：

`最大垃圾收集停顿时间（-XX:MaxGCPauseMillis）` : Parallel Scavenge会调整java堆的大小或者其他参数的大小，尽可能把垃圾回收时间控制在最大垃圾收集停顿时间之内。但是最大收集停顿时间如果设置的太小，则虚拟机会频繁地执行垃圾回收，从而增大了总的垃圾收集时间，降低了吞吐量。

 `垃圾收集时间占比（-XX:GCTimeRatio）`：这个参数直接设置的垃圾回收不得超过多长时间。

 Parallel Scavenge还支持自适应的垃圾收集策略，使用 `-XX:UseAdaptiveSizePolicy`可以打开自适应策略。在该模式下，新生代的大小，eden和Survivor区的比例，晋升老年代的对象年龄等参水会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点，在手工调优比较难的场景下，可以使用中模式让虚拟机自己完成调优工作。

## Serial Old

Serial Old是Serial收集器的老年代版本，采用标记-整理算法，同样也是个串行收集器。

## Parallel Old

Parallel Old是Parallel Scavenge收集器的老年代版本，采用标记-整理算法。

## CMS

CMS（Concurrent Mark Sweep）收集器采用标记-清除算法的老年代并发垃圾收集器，它的目标是要获取最短回收停顿时间。目前大多数java应用集中在基于浏览器的B/S系统的服务端上，这类系统都对api的响应速度有很高的要求，CMS收集器很符合这类应用的需求。

CMS收集器的执行过程分为以下几步：

1. 初始标记（CMS initial mark）：仅仅标记下GC Roots能直接关联到的对象，速度很快。这个阶段需要STW配合。
2. 并发标记（CMS concurrent mark）：这个过程就是荣GC Roots直接关联的对象开始遍历整个图对象的过程，这个过程很长但是不需要暂停用户线程。（ 其实就是标记各个引用链上都有哪些对象）。
3. 重新标记（CMS remark）：这个过程是为了修正在并发标记阶段，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录（之前标记是活的对象，可能在并发标记阶段已经死了，要修改这些对象的标记记录）。这个过程也需要STW配合，暂停时间也要比初始标记阶段的暂停时间长，但远远小于并发阶段花费的时间。
4. 并发清除（CMS concurrent sweep）清除到标记阶段已经判定死亡的对象。这个过程可以与用户应用程序并发执行。

**因为在耗时最长的并发标记和并发清除阶段中，垃圾收集器线程和用户线程可以并发执行，所以总体上说，CMS收集器的内存回收过程是和用户线程一起并发执行的。**

CMS的优点是**并发收集**、**低停顿**。但也有三个很明显的缺点：

1. CMS对处理器资源很敏感。对处理器资源敏感是并发程序的通病。多线程垃圾回收会占用一部分用户的线程，这样会导致用户程序运行变慢。处理器越少、核数越少，多线程回收对用户程序的影响越大。
2. CMS无法处理“浮动垃圾（Floating Garbage）”，因为在并发清除阶段，用户程序仍在运行，这可能会产生新的垃圾，但是这部分垃圾是在标记过程结束后产生的，CMS无法收集他们，只能等待下一次CMS垃圾收集时在清理掉。
3. CMS是基于标记-清除算法的，前面提到过，这种算法收集完对象后内存中会产生大量的空间碎片。这种情况不利于被大对象分配空间。若真遇到大对象在老年代请求内存空间，会触发一次Full GC。（Full GC：收集整个java堆和方法区的垃圾）。

## G1

