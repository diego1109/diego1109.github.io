## 网络协议零星记录

[TOC]

### HTTP和HTTPS的关系

[https协议参考链接](https://juejin.im/post/5e11d2b36fb9a0481d28b4aa)

网络传输有HTTP和HTTPS两种方式，大部分主流网站使用HTTPS，HTTP最大的弊端就是不安全（客户的用户名、密码等信息以明文方式传输给服务器，途中被第三放截获，后果严重）。

> Hypertext Transfer Protocol Secure (HTTPS) is an extension of the Hypertext Transfer Protocol (HTTP). It is used for secure communication over a computer network, and is widely used on the Internet. In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or, formerly, its predecessor, Secure Sockets Layer (SSL). The protocol is therefore also often referred to as HTTP over TLS, or HTTP over SSL.
>
> HTTPS (Hypertext Transfer Protocol Secure) 是基于 HTTP 的扩展，用于计算机网络的安全通信，已经在互联网得到广泛应用。在 HTTPS 中，原有的 HTTP 协议会得到 TLS (安全传输层协议) 或其前辈 SSL (安全套接层) 的加密。因此 HTTPS 也常指 HTTP over TLS 或 HTTP over SSL。

从这段话可以看出，HTTPS是对HTTP的扩展，保证其安全通信。二者关系：HTTPS = HTTP + SSL。



HTTPS解决数据传输安全问题的方案就是使用加密算法，具体来说是混合加密算法，也是就是对称加密和非对称加密混合使用。加密算法可以用密匙加密或者还原数据，当信息在客户端和服务器之前传输时，即使被第三方截获，只要保证密匙不背第三方获取，那就能保证数据传输的安全了。



### 非对称加密

非对称加密就是加密和解密需要使用两个不同的密匙，公匙（public key）和私匙（private key），常用的非对称加密算法是RSA算法。

非对称加密算法实现机密信息交换的基本过程是：

1. 甲方生成一对密匙并将其中一把作为公钥对外公开；
2. 得到该公钥的乙方使用公钥对机密信息加密后在发送给甲方；
3. 甲方再用自己保存的私钥对加密信息进行解密。



### SSL/TLS

[ssl/tls参考链接](https://www.cnblogs.com/Wayou/p/ssl_tls_handshake.html)

SSL（Secure Sockets Layer 安全套阶层）和TLS（Transport Layer Security 安全传输层协议）协议可以为通信双方提供识别和认证通道，从而保证通信的机密性和数据完整性。TLS协议是从SSL协议演变过来的，但这两种协议并不兼容，并且SSL已经被TLS取代。

TLS握手是启动HTTPS通信的过程，类似于TCP/IP建立连接时的三次握手，流程如下：

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/diego1109/diego1109.github.io/images/ssl-handshake.png">
</div>

#### 第一阶段

- client Hello （客户端向服务端发送）
  - 随机数random1
  - 客户端支持的加密套件 Support Ciphers
  - SSL版本

- Server Hello（服务器向客户端发送）
  - 从客户端发送加密套件列表中选择一个，加密套件决定了后续加密及生成摘要的算法。
  - 生成随机数Random2。两端的随机数会在后续生成堆成秘钥时使用。

#### 第二阶段

- Certificate（服务器向客户端发送）
    - 服务器将自己的证书下发给客户端，让客户端验证服务器的身份。（客户端验证身份后从证书中取出公钥。）
- Server Hello Done
    - 通知客户端 server hello 结束。

#### 第三阶段

- Certificate Verity
- - 客户端收到证书后从CA验证其合法性。
  - 验证合法性后从证书中取出公钥，生成随机数Random3
  - 使用公钥非对称加密Random3生成PreMaster Key
- Client Key Exchange
  - 客户端将PreMaster Key发送服务器，服务器用自己的私解出Random3
  - 此时两端都拥有Random1~3
  - 两端使用相同的算法生成密钥，握手结束后都使用此密钥进行堆成加密。（为何需要三个随机数？因为SSL/TSL握手过程中数据明文传输，多个随机数种子生成的密钥不容易暴力破解）。

#### 第四阶段

- Change Cipher Spec（客户端向服务器发送）
    - 这是一条事件消息。
    - 客户端通知服务端后续消息都会使用前面协商出来的密钥加密。
- EnCrypted Handshake Message（客户端向服务器发送）
    - 这是Client Finish消息，客户端将前面的握手消息生成摘要，使用前面协商的密钥加密。
    - 这是客户端发出的第一条加密消息。
    - 服务端使用密匙解密，解密成功说明密匙一致。

- Change Cipher Spec（服务器向客户端发送）
    - 事件消息
    - 服务端通知客户端后续消息都使用加密。
- EnCrypted Handshake Message（服务端向客户端发送）
    - Server Finish消息
    - 服务端将握手过程生成摘要
    - 使用密匙加密发送给客户端
    - 这是服务端发送的第一条加密消息。
    - 客户端收到后解密，解密成功说明密钥一致。



### 数字证书

采用HTTPS协议的服务器必须要有一套数字证书（Certification Authority），证书是需要申请的，并有专门的数字证书认证机构（CA）通过非常严格的审核之后颁发的电子证书。办法证书时同时会产生一个私钥和公钥。私钥由服务器自己保存，不可泄露。公钥则是附带在证书的信息中，可以公开的。证书本身也附带电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。

服务器响应客户端请求，将证书传递给客户端，证书中包含公钥和大量其他的信息，比如证书颁发机构的信息，公司信息和证书的有效期等。客户端解析证书并对其进行验证，如果证书是不可信机构颁发，或者证书中的域名与实际域名不一致，或者证书已经过期，就会像访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥，继续后面的认证步骤。

在非对称加密通信过程中，服务器需要将公钥发送给客户端，在这一过程中，公钥很可能会被第三方拦截并替换，然后这个第三方就可以冒充服务器与客户端进行通信，这就是传说中的“中间人攻击”。解决此问题的方法是通过受信任的第三方交换公钥，具体做法就是服务器不直接向客户端发送公钥，二是要求收信人的第三方，也就是证书认证机构（CA）将公钥合并到数字认证书中，然后服务器会把公钥同证书一起发送给客户端，私钥则由服务器自己保存以确保安全。

数字证书一般包含如下内容：

1. 证书所有者公钥。
2. 证书所有者的专有名称。
3. 证书颁发机构的专有名称。
4. 证书有效起始地址。
5. 证书的过期日期。
6. 证书数据格式版本号。
7. 序列号，这是证书颁发机构为该证书分配的唯一标识符。



### IP地址、子网掩码、网关

[参考链接](https://www.cnblogs.com/JuneWang/p/3917697.html)

#### IP地址

电脑之间要实现网络通信，就必须要有合法的IP地址。`IP地址 = 网络地址+主机号` （又称：网络号和主机号组成）。IP地址通常更为直观，以圆点分隔号的四个十进制数字表示，每个数字从0-255，总共范围是0.0.0.0~247.255.255.255（大概40多亿个IP地址），内网（局域网）有三个地址段：10.0.0.0-10.255.255.255、172.16.0.0-172.31.255.255、192.168.0.0-192.168.255.255，其余地址段都是外网的。

> 比如：192.168.100.2
>
> 这是个内网IP，网络地址：192.168.100，主机号：2。

#### 子网掩码

网络地址就是判断网络中的计算机在不在同一网络中，在就能相互通信，不在就不能相互通信。那怎么计算计算机的网络地址呢？这里要用到“子网掩码”，简单来说子网掩码就是用来判断IP地址的网络地址和主机号是什么。

> 比如：要判断一个IP地址：192.168.1.199的网络号和主机号分别是什么？凭什么说192.168.1是网络号，199是主机号。即便这个回答跟真是答案一样，但也缺少依据。
>
> 现在有个IP地址：192.168.1.199，它的子网掩码是：255.255.255.0。这种场景下，说192.168.1是网络号，199是主机号就是准确无误了。怎么计算的呢？
>
> 子网掩码转换成二进制：255.255.255.0 **‐＞**11111111.11111111.11111111.00000000
>
> 子网掩码的左边是网络位，用二进制“1”表示，且1的数目等于网络位的长度（子网掩码255.255.255.0的 “1”的个数是左边24位，则对应IP地址左边的位数也是24位），右边是主机位，用二进制“0”表示，且0的数目等于主机位的长度。
>
> IP 地址的二进制：192.168.1.199 **‐＞\*11000000.10101000.00000001\***.11000111
>
> 则这个IP地址的网络号就是11000000.10101000.00000001 ，转换成十进制就是 192.168.1，网掩码255.255.255.0的 “0”的个数是右边8位，则这个IP地址的主机号就是11000111，转换成十进制就是199.

#### 网关

网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192.168.1.254”，子网掩码：255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254” ，子网掩码：255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使两个网络连接同一台交换机（或者集线器）上，TCP/IP也会根据子网掩码判定两个网络中的主机不在同一个网络中。而要想实现两个网络之间的通信，则就必须通过网关。

如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包发送给他自己的网关，再由网关A转发给网络B的网关，网络B的网关再转发給网络B的某个主机。所以说只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。

那网关的IP地址是哪台机器的IP地址呢？网关的IP地址是具有“路由”功能设备的IP地址，具有路由功能的设备有 **路由器**、**启用了路由协议的服务器（实质上相当一台路由器）**、**代理服务器**。



### ARP协议

[参考链接](https://blog.csdn.net/u010164190/article/details/79446575?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)

#### ARP协议到底是干什么的？

我们都知道局域网中的通信，都是靠MAC地址来通信的。ARP简单说，就是用来把IP地址转换成MAC地址。

<div align="center">
    <img src="https://cdn.jsdelivr.net/gh/diego1109/diego1109.github.io/images/arp-protocal.jpg">
</div>

当我们在电脑发送消息时，电脑内部的处理机制显示从上层开始一层一层往下封装。到了二层，要封装帧头部时，就需要把目的mac地址分装上，形成完成的二层头部后，就可以发送出去了。

但问题就是，电脑如何目的的MAC地址呢？

比如在一个局域网内，计算机A要给计算机E发送消息，而且他们是第一次通信。计算机A会把信息先从上层往下层封装，到了第二层，需要将目的MAC地址、源MAC地址进行封装，A肯定知道自己的MAC地址，但它却不知道E的。这时候A就执行ARP程序，发送一个ARP请求报文的广播包

>二层：
>目的MAC地址：ffff.ffff.ffff.ffff
>源mac地址：1111.1111.1111.1111
>类型：0x0806
>arp的关键内容如下：
>source mac：1111.1111.1111.1111.1111
>source IP： 1.1.1.1
>target mac：ffff.ffff.ffff.ffff （因为第一次通信，不知道对方的mac地址）
>target IP：1.1.1.2

交换机看到目的MAC全是F就进行广播，这样一来，局域网中的所有计算机都收到这个广播包，会进行更深入解析，看到里面 `target IP：1.1.1.2` 与自己的IP地址进行比对，发现不一样，就丢弃。发现一样，就回应APP报文（单波回应）。

ARP的响应报文里的关键字如下：

>二层：
>
>目的MAC地址：1111.1111.1111.1111
>源mac地址：2222.2222.2222.2222
>类型：0x0806
>arp的关键内容如下：
>source mac：**2222.2222.2222.2222**
>source IP： 1.1.1.1
>target mac：1111.1111.1111.1111 （从请求包里得知A的mac地址，于是单播）
>target IP：1.1.1.1

 这样，计算机A收到这个报文后，就将计算机E的mac地址记录下来，存在计算机A的ARP缓存表中。下次通信时没如果缓存表未超时，就可以直接使用了。如果超时了，就再次进行ARP请求广播。

